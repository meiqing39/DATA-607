---
title: "Project 1"
author: "Mei Qi Ng"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## [**Approach**]{.underline}

In this project, we are given a text file with chess tournament results where information has some structure. The goal is to create an R markdown file that generates a .CSV file (that could be for example imported into a SQL database) with the following information for all players:

### *Player’s Name, Player’s State, Total Number of Points, Player’s Pre-Rating, and Average Pre Chess Rating of Opponents*

```{r echo=FALSE, out.width="40%", fig.align="center"}
knitr::include_graphics("https://images.pexels.com/photos/277092/pexels-photo-277092.jpeg")

```

(1) Data Loading: The tournament text file will be posted on Github, which allows me to load the data frame.

(2) Data Tidying: Based on looking at raw tournament txt file, I see that there are some rows of lines and other cells that will need to be cleared up , columns that are not needed for calculation, renaming columns for clarity, rearranging, and changing of characters to integers for easier workaround for this data frame.

(3) Create CSV: With this newly cleaned up version of this table, a csv file will be created and used to analyze the tournament information.

# SOURCE:

(1) Gemini Pro - 
(2) [Posit Stringr/Regrex cheatsheet](https://posit.co/wp-content/uploads/2022/10/strings-1.pdf)
(3) 

```{r}
#load data

library(tidyverse)

raw_data <- read.csv("https://raw.githubusercontent.com/meiqing39/DATA-607/refs/heads/main/Project_1/tournamentinfo.txt")

head(raw_data)
```

```{r}
#remove first 2 rows of non data

new_df <- raw_data |> 
  filter(!row_number()%in% c(1:2)) |> 
  rename(raw_text = 1) |> 
  filter(!str_detect(raw_text, "^-+$"))  #remove rows with 1+ dashes 

head(new_df)

```

```{r}
r1_data <- new_df |> 
  filter(row_number() %% 2== 1)
r2_data <-new_df |> 
  filter(row_number()%%2 ==0)

#create columns with |
split1 <- str_split(r1_data$raw_text, "\\|", simplify = TRUE)

split2 <- str_split(r2_data$raw_text, "\\|", simplify = TRUE)
  
head(split1)

head(split2)

# 4. Extract the easy columns thats already there and trim white space

player_name  <- str_trim(split1[, 2])
player_state <- str_trim(split2[, 1])
total_points <- as.numeric(str_trim(split1[, 3]))

# 5. Extract the Pre-Rating
# Looks for "R:", any spaces, and then digits. Then we remove the "R: " part to just keep the number.

pre_rating <- str_extract(split2[, 2], "R:\\s*\\d+") |> 
  str_remove("R:\\s*") |> 
  as.numeric()

# 6. Calculate Average Opponent Pre-Rating
# Columns 4 through 10 of split1 contain the round results (e.g., "W  39")
per_round <- split1[, 4:10]

# Create a function to find the average for a single player
calc_avg_op_rating <- function(player_rounds, all_ratings) {
  # Pull just the numbers from the rounds (e.g., "W  39" becomes 39)
  opp_nums <- as.numeric(str_extract(player_rounds, "\\d+"))
  # Remove NAs (rounds where they had a bye or didn't play)
  opp_nums <- opp_nums[!is.na(opp_nums)]
  # Look up those opponent's ratings in the pre_rating vector and average them
  round(mean(all_ratings[opp_nums], na.rm = TRUE))
}

# Apply this function across every player's row
avg_op_rating <- apply(per_round, 1, calc_avg_op_rating, all_ratings = pre_rating)

# 7. Bind it all together to final dataset

final_chess_data <- tibble(
  Player_Name = player_name,
  Player_State = player_state,
  Total_Points = total_points,
  Pre_Rating = pre_rating,
  Avg_Opponent_Rating = avg_op_rating
)

# Take a look at the final result!
head(final_chess_data)

```
